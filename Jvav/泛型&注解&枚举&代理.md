# 泛型 & 注解 & 枚举类 & 代理

- [泛型 & 注解 & 枚举类 & 代理](#泛型--注解--枚举类--代理)
  - [泛型难点](#泛型难点)
    - [集合中使用泛型总结](#集合中使用泛型总结)
    - [类](#类)
    - [接口](#接口)
    - [方法](#方法)
    - [数组](#数组)
    - [总结](#总结)
  - [注解](#注解)
  - [枚举](#枚举)
  - [代理模式的原理](#代理模式的原理)
    - [静态代理](#静态代理)
    - [动态代理](#动态代理)

## 泛型难点

1. 类A是类B的父类，G\<A>和G\<B>是没关系的，二者共同的父类是：G<?>.补充：类A是类B的父类，A\<G> 是 B\<G> 的父类
2. 限制条件的通配符的使用
   - ? extends A: G<? extends A> 可以作为G\<A>和G\<B>的父类，其中B是A的子类 ，上界通配符顾名思义，<? extends T>表示的是类型的上界【包含自身】，因此通配的参数化类型可能是T或T的子类。
   - ? super A: G<? super A> 可以作为G\<A>和G\<B>的父类，其中B是A的父类，下界通配符<? super T>表示的是参数化类型是T的超类型（包含自身），层层至上，直至Object

- 泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型
- 泛型只在编译阶段有效
- 泛型要声明之后才能使用
- 不同泛型不能相互赋值
- 通配符 "?" 是实参 和Number、String、Integer一样都是一种实际的类型,看作是所有类的父类

1. E  集合中使用 element
1. T Type java类
1. K
1. V
1. N number 数值类型

```java
//在集合中使用泛型的情况：以HashMap为例
@Test
public void test3(){
//        Map<String,Integer> map = new HashMap<String,Integer>();
    //jdk7新特性：类型推断
    Map<String,Integer> map = new HashMap<>();
    map.put("Tom",87);
    map.put("Jerry",87);
    map.put("Jack",67);
//        map.put(123,"ABC");
    //泛型的嵌套
    Set<Map.Entry<String,Integer>> entry = map.entrySet();
    Iterator<Map.Entry<String, Integer>> iterator = entry.iterator();
    while(iterator.hasNext()){
        Map.Entry<String, Integer> e = iterator.next();
        String key = e.getKey();
        Integer value = e.getValue();
        System.out.println(key + "----" + value);}}
```

### 集合中使用泛型总结

1. 集合接口或集合类在jdk5.0时都修改为带泛型的结构。
2. 在实例化集合类时，可以指明具体的泛型类型
3. 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。
   - 比如：add(E e)  --->实例化以后：add(Integer e)
4. 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换
5. 如果实例化时，没指明泛型的类型。默认类型为java.lang.Object类型。

### 类

1. 明确\<T>,才是泛型类，继承父类的泛型自己不声明，自己不是泛型类。
1. 只是会被父类泛型限制
1. 传入实参 限制类型
1. 不传入实参 则无任何限制
1. 泛型边界 上边界  指定为number的子类

```java
public void showKeyValue1(Generic<? extends Number> obj){
        Log.d("泛型测试","key value is " + obj.getKey());}
```

### 接口

实现的时候的就一定要传入泛型实参

### 方法

- 只有声明了"\<T>"的才是泛型方法,一般在public和返回值之间，
- 泛型方法在声明的时候会声明泛型\<E>，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型
- 无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。

```java
public <E> void show_3(E t){ // <E> 是给编译器指明形参的 泛型指定
        System.out.println(t.toString());}

//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。
    public <T> void show_2(T t){
        System.out.println(t.toString());
    }
静态泛型方法 在使用时调用才是正常的，实例化的时候调用会报错
如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。
//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的<T>上添加上下边界，即在泛型声明的时候添加
//public <T> T showKeyName(Generic<T extends Number> container)，编译器会报错："Unexpected bound"
public <T extends Number> T showKeyName(Generic<T> container){
    System.out.println("container key :" + container.getKey());
    T test = container.getKey();
    return test;
}
泛型的上下边界添加，必须与泛型的声明在一起 。
```

### 数组

- 不能创建一个确切的泛型类型的数组
- 数组的类型不可以是类型变量，除非是采用通配符的方式

### 总结

1. 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：<E1,E2,E3>
2. 泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass\<E>(){}
3. 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。
4. 泛型不同的引用不能相互赋值。尽管在编译时ArrayList\<String>和ArrayList\<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。
5. 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。经验：泛型要使用一路都用。要不用，一路都不要用。
6. 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。
7. jdk1.7，泛型的简化操作：ArrayList\<Fruit> flist = new ArrayList<>();
8. 泛型的指定中不能使用基本数据类型，可以使用包装类替换。
9. 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。
10. 异常类不能是泛型的
11. 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity];参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。
12. 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：
    1. 子类不保留父类的泛型：按需实现
       - 没有类型 擦除
       - 具体类型
    1. 子类保留父类的泛型：泛型子类
       - 全部保留
       - 部分保留
结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型

```java
@Test
public void test1(){
    Object obj = null;
    String str = null;
    obj = str;
    Object[] arr1 = null;
    String[] arr2 = null;
    arr1 = arr2;
    //编译不通过
//        Date date = new Date();
//        str = date;
    List<Object> list1 = null;
    List<String> list2 = new ArrayList<String>();
    //此时的list1和list2的类型不具子父类关系
    //编译不通过
//        list1 =list2;
    
    // 反证法：
    // 假设list1 = list2;
    //   list1.add(123);导致混入非String的数据。出错。

    show(list1);
    show1(list2);}

public void show1(List<String> list){}
public void show(List<Object> list){}
@Test
public void test2(){
    AbstractList<String> list1 = null;
    List<String> list2 = null;
    ArrayList<String> list3 = null;
    list1 = list3;
    list2 = list3;
    List<String> list4 = new ArrayList<>();}
```

## 注解

框架 = 注解 + 反射机制 + 设计模式

- @Override: 限定重写父类方法, 该注解只能用于方法
- @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的择
- @SuppressWarnings: 抑制编译器警告

元注解 ：对现有的注解进行解释说明的注解

jdk 提供的4种元注解：

- Retention：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为\RUNTIME 只声明为RUNTIME生命周期的注解，才能通过反射获取。
- Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素
- Documented:表示所修饰的注解在被javadoc解析时，保留下来。
- Inherited:被它修饰的 Annotation 将具继承性。

--->类比：元数据的概念：String name = "Tom";
如何获取注解信息:通过反射来进行获取、调用。
前提：要求此注解的元注解Retention中声明的生命周期状态为：RUNTIME.
JDK8中注解的新特性：可重复注解、类型注解
可重复注解: 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class
MyAnnotation的Target和Retention等元注解与MyAnnotations相同。
类型注解：

- ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明。
- ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。

## 枚举

枚举类的说明：

- 枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类
- 当需要定义一组常量时，强烈建议使用枚举类
- 如果枚举类中只一个对象，则可以作为单例模式的实现方式。

```java
//自定义枚举类
class Season{
    //1.声明Season对象的属性:private final修饰
    private final String seasonName;
    private final String seasonDesc;
    //2.私化类的构造器,并给对象属性赋值
    private Season(String seasonName,String seasonDesc){
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;}

    //3.提供当前枚举类的多个对象：public static final的
    public static final Season SPRING = new Season("春天","春暖花开");
    public static final Season SUMMER = new Season("夏天","夏日炎炎");
    public static final Season AUTUMN = new Season("秋天","秋高气爽");
    public static final Season WINTER = new Season("冬天","冰天雪地");
    //4.其他诉求1：获取枚举类对象的属性
    public String getSeasonName() {
        return seasonName;}

    public String getSeasonDesc() {
        return seasonDesc;}

    //4.其他诉求1：提供toString()
    @Override
    public String toString() {
        return "Season{" +
                "seasonName='" + seasonName + '\'' +
                ", seasonDesc='" + seasonDesc + '\'' +
                '}';}}
jdk 5.0 新增使用enum定义枚举类。步骤：
//使用enum关键字枚举类
enum Season1 {
    //1.提供当前枚举类的对象，多个对象之间用","隔开，末尾对象";"结束
    SPRING("春天", "春暖花开"), SUMMER("夏天", "夏日炎炎"), AUTUMN("秋天", "秋高气爽"), WINTER("冬天", "冰天雪地");
    //2.声明Season对象的属性:private final修饰
    private final String seasonName;
    private final String seasonDesc;
    //2.私化类的构造器,并给对象属性赋值
    private Season1(String seasonName, String seasonDesc) {
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;}

    //4.其他诉求1：获取枚举类对象的属性
    public String getSeasonName() {
        return seasonName;}

    public String getSeasonDesc() {
        return seasonDesc;}}

    使用enum定义枚举类之后，枚举类常用方法：（继承于java.lang.Enum类）
    Season1 summer = Season1.SUMMER;
    //toString():返回枚举类对象的名称
    System.out.println(summer.toString());
    //        System.out.println(Season1.class.getSuperclass());
    System.out.println("****************");
    //values():返回所的枚举类对象构成的数组
    Season1[] values = Season1.values();for(
    int i = 0;i<values.length;i++)
    {
        System.out.println(values[i]);
    }System.out.println("****************");
    Thread.State[] values1 = Thread.State.values();for(
    int i = 0;i<values1.length;i++)
    {
        System.out.println(values1[i]);
    }
    //valueOf(String objName):返回枚举类中对象名是objName的对象。
    Season1 winter = Season1.valueOf("WINTER");
    //如果没objName的枚举类对象，则抛异常：IllegalArgumentException
    //        Season1 winter = Season1.valueOf("WINTER1");
    System.out.println(winter);
    5. 使用enum定义枚举类之后，如何让枚举类对象分别实现接口：
    interface Info {
        void show();}

    //使用enum关键字枚举类
enum Season1 implements Info{
    //1.提供当前枚举类的对象，多个对象之间用","隔开，末尾对象";"结束
    SPRING("春天","春暖花开"){
        @Override
        public void show() {
            System.out.println("春天在哪里？");}},

    SUMMER("夏天","夏日炎炎"){
        @Override
        public void show() {
            System.out.println("宁夏");}},

    AUTUMN("秋天","秋高气爽"){
        @Override
        public void show() {
            System.out.println("秋天不回来");}},

    WINTER("冬天","冰天雪地"){
        @Override
        public void show() {
            System.out.println("大约在冬季");}};}
```

## 代理模式的原理

使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。
代理对象决定是否以及何时将方法调用转到原始对象上

### 静态代理

1. 举例

    ```java
    // 实现Runnable接口的方法创建多线程。
    Class MyThread implements Runnable{} //相当于被代理类
    Class Thread implements Runnable{} //相当于代理类
    main(){
    MyThread t = new MyThread();
    Thread thread = new Thread(t);
    thread.start();//启动线程；调用线程的run()}
    ```

2. 静态代理的缺点：

- 代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。
- 每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。

### 动态代理

动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对
象。

动态代理的实现
需要解决的两个主要问题：
问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。 （通过Proxy.newProxyInstance()实现）
问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。(通过InvocationHandler接口的实现类及其方法invoke())

```java
interface Human{
    String getBelief();
    void eat(String food);
}
//被代理类
class SuperMan implements Human{
    @Override
    public String getBelief() {
        return "I believe I can fly!";}

    @Override
    public void eat(String food) {
        System.out.println("我喜欢吃" + food);}}

class HumanUtil{
    public void method1(){
        System.out.println("====================通用方法一====================");}

    public void method2(){
        System.out.println("====================通用方法二====================");}}

class ProxyFactory{
    //调用此方法，返回一个代理类的对象。解决问题一
    public static Object getProxyInstance(Object obj){//obj:被代理类的对象
        MyInvocationHandler handler = new MyInvocationHandler();
        handler.bind(obj);
        return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);}}
        
class MyInvocationHandler implements InvocationHandler{
    private Object obj;//需要使用被代理类的对象进行赋值
    public void bind(Object obj){
        this.obj = obj;}

    //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()
    //将被代理类要执行的方法a的功能就声明在invoke()中
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        HumanUtil util = new HumanUtil();
        util.method1();
        //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法
        //obj:被代理类的对象
        Object returnValue = method.invoke(obj,args);
        util.method2();
        //上述方法的返回值就作为当前类中的invoke()的返回值。
        return returnValue;}}

public class ProxyTest {
    public static void main(String[] args) {
        SuperMan superMan = new SuperMan();
        //proxyInstance:代理类的对象
        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);
        //当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法
        String belief = proxyInstance.getBelief();
        System.out.println(belief);
        proxyInstance.eat("四川麻辣烫");
        System.out.println("*****************************");
        NikeClothFactory nikeClothFactory = new NikeClothFactory();
        ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);
        proxyClothFactory.produceCloth();}}
```
