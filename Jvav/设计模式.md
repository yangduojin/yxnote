![](/Jvav/img/designPatternsCategory.png)

- [适配器模式](#适配器模式)
- [装饰模式(Decorator)(包装器模式(Wrapper))](#装饰模式decorator包装器模式wrapper)
- [工厂模式](#工厂模式)
- [抽象工厂模式](#抽象工厂模式)
- [策略模式及与工厂模式的区别](#策略模式及与工厂模式的区别)
- [单例模式](#单例模式)
- [观察者模式](#观察者模式)

## 适配器模式

FutureTask 本身实现了RunnableFuture,构造器又注入了Callable,这是一个适配器模式

1. 构造方法一：传入参数为Callable接口

```java
public class FutureTask<V> implements RunnableFuture<V> 
public FutureTask(Callable<V> callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable}
```

2. 构造方法二：传入的参数为Runnable接口

```java
// 这是FutureTask的构造方法
public FutureTask(Runnable runnable, V result) {
    // 调用Executors类中的callable方法进行转化
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable}
```

- Executors类中的callable方法

```java
public static <T> Callable<T> callable(Runnable task, T result) {
    if (task == null)
        throw new NullPointerException();
    // 返回类型是Callable
    // 这里就开始使用适配器模式了
    return new RunnableAdapter<T>(task, result);}
```

- 在Executors中内部类：即我们的适配器类

```java
// 实现了Callable接口
static final class RunnableAdapter<T> implements Callable<T> {
    final Runnable task;
    final T result;
    // 传入Runnable接口（实现类）和返回值
    RunnableAdapter(Runnable task, T result) {
        this.task = task;
        this.result = result;}

    // 实现call（）方法
    public T call() {
        // 在call方法中调用Runnable实现类中的run（）方法
        // 变相实现了将Runnable转化为Callable的过程
        task.run();
        // 返回值（Callable接口的call方法有返回值）
        return result;}}
```

## 装饰模式(Decorator)(包装器模式(Wrapper))

```java
public interface Strategy {
     public void operate();}


//妙计一：初到吴国
public class BackDoor implements Strategy {
     @Override
     public void operate() {
          System.out.println("找乔国老帮忙，让吴国太给孙权施加压力，使孙权不能杀刘备");}}

// 三个实现类（ConcreteStrategy）

//求吴国太开绿灯放行
public class GivenGreenLight implements Strategy {
     @Override
     public void operate() {
          System.out.println("求吴国太开个绿灯，放行");}}
 
//孙夫人断后，挡住追兵
public class BlackEnemy implements Strategy {
     @Override
     public void operate() {
          System.out.println("孙夫人断后，挡住追兵");}}
```

环境类（Context)

```java
public class Context {
     private Strategy strategy;
     //构造函数，要你使用哪个妙计
     public Context(Strategy strategy){
          this.strategy = strategy;}
     
     public void setStrategy(Strategy strategy){
          this.strategy = strategy;}
     
     public void operate(){
          this.strategy.operate();}}
```

下面就是使用的情况了

```java
public class Zhaoyun {
 
public static void main(String[] args) {
     Context context;
 
     System.out.println("----------刚到吴国使用第一个锦囊---------------");
     context = new Context(new BackDoor());
     context.operate();
     System.out.println("\n");
 
     System.out.println("----------刘备乐不思蜀使用第二个锦囊---------------");
     context.setStrategy(new GivenGreenLight());
     context.operate();
     System.out.println("\n");
 
     System.out.println("----------孙权的追兵来了，使用第三个锦囊---------------");
     context.setStrategy(new BlackEnemy());
     context.operate();
     System.out.println("\n");}}
```

## 工厂模式

```java
public interface Sender {  
    public void Send();}  

public class MailSender implements Sender {  
    @Override  
    public void Send() {  
        System.out.println("this is mailsender!");}}  

public class SmsSender implements Sender {  

    @Override  
    public void Send() {  
        System.out.println("this is sms sender!");  }}  

public class SendFactory {  

    public static Sender produceMail(){  
        return new MailSender();}  

    public static Sender produceSms(){  
        return new SmsSender();}}  

public class FactoryTest {  

    public static void main(String[] args) {      
        Sender sender = SendFactory.produceMail();  
        sender.Send();}}  
```

## 抽象工厂模式

```java
public interface Provider {  
    public Sender produce();}  

public class SendMailFactory implements Provider {  

    @Override  
    public Sender produce(){  
        return new MailSender();}}  

public class SendSmsFactory implements Provider{  

    @Override  
    public Sender produce() {  
        return new SmsSender();}}  

public class Test {  

    public static void main(String[] args) {  
        Provider provider = new SendMailFactory();  
        Sender sender = provider.produce();  
        sender.Send();  }}  
// 总结：如果要新增发送微信，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！
// 所有工厂模式中，抽象工厂模式最先进。
```

## 策略模式及与工厂模式的区别

- 定义与使用场合：一个系统需要动态地在几种类似的算法中选择一种。
- 与工厂模式异同：实例化一个对象的位置不同。对工厂模式而言，实例化对象是放在了工厂类里面。而策略模式实例化对象的操作在调用的地方。本质都是继承与多态。
- 例子： 现有 加/减/乘 几种算法，输入参数返回值都一样（可以理解成类似的算法）。现在需要在调用时动态配置算法策略，实现对不同算法的调用。

```java
public interface Strategy {
   public int doOperation(int num1, int num2);}

public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 + num2;}}

public class OperationSubstract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 - num2;}}

public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 * num2;}}

public class Context {
   private Strategy strategy;

   public Context(Strategy strategy){
      this.strategy = strategy;}

   public int executeStrategy(int num1, int num2){
      return strategy.doOperation(num1, num2);}}

public class StrategyPatternDemo {
   public static void main(String[] args) {
       //实例化对象的位置在调用处
      Context context = new Context(new OperationAdd());        
      System.out.println("10 + 5 = " + context.executeStrategy(10, 5));

      context = new Context(new OperationSubstract());        
      System.out.println("10 - 5 = " + context.executeStrategy(10, 5));

      context = new Context(new OperationMultiply());        
      System.out.println("10 * 5 = " + context.executeStrategy(10, 5));}}
```

## 单例模式

```java
// 懒汉
class Bank {
    private Bank() {}
    private volatile static Bank instance = null;
    public static Bank getInstance() {
        // 方式一：效率稍差
        // synchronized (Bank.class) {
        // if(instance == null){
        // instance = new Bank();}
        // return instance;}

        // 方式二：效率更高,双重检索
        if (instance == null) {
            synchronized (Bank.class) {
                if (instance == null) {
                    instance = new Bank();}}}
    return instance;}}

// 饿汉
public class SingleTon1(){
    private SingleTon1(){}
    private static SingleTon1 singleton = new SingleTon1();
public static getInstance(){return singleton ;}}

// 静态内部类,推荐此方式;JVM类加载机制来保证初始化实例对象时只有一个线程
public class Singleton {
    private Singleton() {}
    public static Singleton getInstance() {return SingletonHolder.sInstance;}
    private static class SingletonHolder {
        private static final Singleton sInstance = new Singleton();}}
```

## 观察者模式

一个对象(subject)被其他多个对象(observer)所依赖。则当一个对象变化时，发出通知，其它依赖该对象的对象都会收到通知，并且随着变化。

比如 声音报警器和闪光灯报警器分别订阅热水器温度，热水器温度过高时，发出通知，两个报警器分别发声、闪光以实现报警。
又比如很多人订阅微信公众号，该公众号有更新文章时，自动通知每个订阅的用户。

```java
public interface Observer {  
    public void update();}  

public class Observer1 implements Observer {  

    @Override  
    public void update() {  
        System.out.println("observer1 has received!");}}  

public class Observer2 implements Observer {  

    @Override  
    public void update() {  
        System.out.println("observer2 has received!");}}

public interface Subject {  

    /*增加观察者*/  
    public void add(Observer observer);  

    /*删除观察者*/  
    public void del(Observer observer);  

    /*通知所有的观察者*/  
    public void notifyObservers();  

    /*自身的操作*/  
    public void operation();}

public abstract class AbstractSubject implements Subject {  

    private Vector<Observer> vector = new Vector<Observer>();  
    @Override  
    public void add(Observer observer) {  
        vector.add(observer);}

    @Override  
    public void del(Observer observer) {  
        vector.remove(observer);}

    @Override  
    public void notifyObservers() {  
        Enumeration<Observer> enumo = vector.elements();  
        while(enumo.hasMoreElements()){  
            enumo.nextElement().update();}}

public class MySubject extends AbstractSubject {  

    @Override  
    public void operation() {  
        System.out.println("update self!");  
        notifyObservers();}}

public class ObserverTest {  

    public static void main(String[] args) {  
        Subject sub = new MySubject();  
        sub.add(new Observer1());  //订阅这个对象
        sub.add(new Observer2());  

        sub.operation();  //发出改变的一个通知}} 

```










