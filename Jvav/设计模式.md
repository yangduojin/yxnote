![](/Jvav/img/designPatternsCategory.png)

## 适配器模式

FutureTask 本身实现了RunnableFuture,构造器又注入了Callable,这是一个适配器模式

### 构造方法一：传入参数为Callable接口

```java
public class FutureTask<V> implements RunnableFuture<V> 
public FutureTask(Callable<V> callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
}
```

### 构造方法二：传入的参数为Runnable接口

```java
// 这是FutureTask的构造方法
public FutureTask(Runnable runnable, V result) {
    // 调用Executors类中的callable方法进行转化
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
}
```

- Executors类中的callable方法

```java
public static <T> Callable<T> callable(Runnable task, T result) {
    if (task == null)
        throw new NullPointerException();
    // 返回类型是Callable
    // 这里就开始使用适配器模式了
    return new RunnableAdapter<T>(task, result);
}
```

- 在Executors中内部类：即我们的适配器类

```java
// 实现了Callable接口
static final class RunnableAdapter<T> implements Callable<T> {
    final Runnable task;
    final T result;
    // 传入Runnable接口（实现类）和返回值
    RunnableAdapter(Runnable task, T result) {
        this.task = task;
        this.result = result;
    }
    // 实现call（）方法
    public T call() {
        // 在call方法中调用Runnable实现类中的run（）方法
        // 变相实现了将Runnable转化为Callable的过程
        task.run();
        // 返回值（Callable接口的call方法有返回值）
        return result;
    }
}
```