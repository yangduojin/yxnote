# 设计模式

- [设计模式](#设计模式)
  - [设计思想](#设计思想)
  - [SOLID原则](#solid原则)
  - [创建型](#创建型)
    - [类 工厂模式](#类-工厂模式)
    - [对象 抽象工厂模式](#对象-抽象工厂模式)
    - [对象 单例模式](#对象-单例模式)
    - [对象 建造者模式](#对象-建造者模式)
  - [结构型](#结构型)
    - [类 适配器模式](#类-适配器模式)
      - [适配器模式演示2](#适配器模式演示2)
    - [对象 装饰模式(Decorator)(包装器模式(Wrapper))](#对象-装饰模式decorator包装器模式wrapper)
    - [对象 代理模式](#对象-代理模式)
    - [对象 桥接模式](#对象-桥接模式)
  - [行为型](#行为型)
    - [类](#类)
    - [对象 观察者模式](#对象-观察者模式)
    - [对象 策略模式 & 与工厂模式的区别](#对象-策略模式--与工厂模式的区别)
      - [策略模式演示2](#策略模式演示2)

## 设计思想

1. 产品命名：以简单有趣为荣，以平庸难记为耻。

2. 单个函数：以短小精悍为荣，以冗长费神为耻。

3. 代码维护：以持续重构为荣，以停滞不前为耻。

4. 编程风格：以运用风格为荣，以随意编码为耻。

5. 程序设计：以开关上线为荣，以自信编码为耻。

6. 接口定义：以用户易用为荣，以复杂歧义为耻。

7. 断言分支：以实时报警为荣，以忽略分支为耻。

8. 监控报警：以定时调整为荣，以放弃维护为耻。

## SOLID原则

1. **SRP：单一职责原则**，任何一个软件模块应该只对某一类行为者负责。是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。
2. **OCP：开闭原则**，设计良好的软件应该易于扩展(对扩展开放)，同时抗拒修改(对修改关闭)。是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性
   1. 对软件测试的影响: 软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。
   2. 可以提高代码的可复用性: 粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。
   3. 可以提高软件的可维护性: 遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。
   - 可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。
   - 因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。
3. **LSP：里氏替换原则**，尽量使用抽象(如父类)，避免使用具体(如子类)，以便于方便的进行替换。里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
   1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
   2. 子类中可以增加自己特有的方法
   3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
   4. 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等
4. **ISP：接口隔离原则**，客户端不应该依赖于它不需要的接口。这里啰嗦两句，Bob大叔在自己的巅峰之作《架构整洁之道》中详细介绍了SOLID原则，后来设计原则逐渐演变为六大，多出来的一个是LOD迪米特法则，又称最少知识原则，我一直找不到六大设计原则的出处，知道的朋友还烦请告知。我个人观点，接口隔离原则与迪米特法则异曲同工，所以没有必要放进来。
   1. 优点:将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
   2. 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
   3. 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
   4. 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
   5. 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。
   - 实现: 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
   - 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
   - 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
   - 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。
5. **DIP：依赖反转原则**，多使用抽象接口，尽量避免使用多变的实现类。在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。
   1. 优点: 依赖倒置原则可以降低类间的耦合性。
   2. 依赖倒置原则可以提高系统的稳定性。
   3. 依赖倒置原则可以减少并行开发引起的风险。
   4. 依赖倒置原则可以提高代码的可读性和可维护性。
   - 实现: 每个类尽量提供接口或抽象类，或者两者都具备。
   - 变量的声明类型尽量是接口或者是抽象类。
   - 任何类都不应该从具体类派生。
   - 使用继承时尽量遵循里氏替换原则。

|设计原则 |一句话归纳 |目的|
|---|---|---|
|开闭原则| 对扩展开放，对修改关闭| 降低维护带来的新风险|
|依赖倒置原则| 高层不应该依赖低层，要面向接口编程| 更利于代码结构的升级扩展|
|单一职责原则| 一个类只干一件事，实现类要单一| 便于理解，提高代码的可读性|
|接口隔离原则| 一个接口只干一件事，接口要精简单一| 功能解耦，高聚合、低耦合|
|迪米特法则| 不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度| 只和朋友交流，不和陌生人说话，减少代码臃肿|
|里氏替换原则| 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义| 防止继承泛滥|
|合成复用原则| 尽量使用组合或者聚合关系实现代码复用，少使用继承| 降低代码耦合|

实际上，这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。  
记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。  
在程序设计时，我们应该将程序功能最小化，每个类只干一件事。若有类似功能基础之上添加新功能，则要合理使用继承。对于多方法的调用，要会运用接口，同时合理设置接口功能与数量。最后类与类之间做到低耦合高内聚。

![设计模式总分类](/Jvav/img/designPatternsCategory.png)

## 创建型

1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
2. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
3. 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
4. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
5. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

### 类 工厂模式

```java
public interface Sender {  
    public void Send();}  

public class MailSender implements Sender {  
    @Override  
    public void Send() {  
        System.out.println("this is mailsender!");}}  

public class SmsSender implements Sender {  

    @Override  
    public void Send() {  
        System.out.println("this is sms sender!");  }}  

public class SendFactory {  

    public static Sender produceMail(){  
        return new MailSender();}  

    public static Sender produceSms(){  
        return new SmsSender();}}  

public class FactoryTest {  

    public static void main(String[] args) {      
        Sender sender = SendFactory.produceMail();  
        sender.Send();}}  
```

### 对象 抽象工厂模式

```java
public interface Provider {  
    public Sender produce();}  

public class SendMailFactory implements Provider {  

    @Override  
    public Sender produce(){  
        return new MailSender();}}  

public class SendSmsFactory implements Provider{  

    @Override  
    public Sender produce() {  
        return new SmsSender();}}  

public class Test {  

    public static void main(String[] args) {  
        Provider provider = new SendMailFactory();  
        Sender sender = provider.produce();  
        sender.Send();  }}  
// 总结：如果要新增发送微信，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！
// 所有工厂模式中，抽象工厂模式最先进。
```

### 对象 单例模式

```java
// 懒汉
class Bank {
    private Bank() {}
    private volatile static Bank instance = null;
    public static Bank getInstance() {
        // 方式一：效率稍差
        // synchronized (Bank.class) {
        // if(instance == null){
        // instance = new Bank();}
        // return instance;}

        // 方式二：效率更高,双重检索
        if (instance == null) {
            synchronized (Bank.class) {
                if (instance == null) {
                    instance = new Bank();}}}
    return instance;}}

// 饿汉
public class SingleTon1(){
    private SingleTon1(){}
    private static SingleTon1 singleton = new SingleTon1();
public static getInstance(){return singleton ;}}

// 静态内部类,推荐此方式;JVM类加载机制来保证初始化实例对象时只有一个线程
public class Singleton {
    private Singleton() {}
    public static Singleton getInstance() {return SingletonHolder.sInstance;}
    private static class SingletonHolder {
        private static final Singleton sInstance = new Singleton();}}

// 使用容器实现单例模式
public class SingletonManager {
    private static Map<String, Object> objMap = new HashMap<String, Object>();
    private Singleton() { }public static void registerService(String key, Objectinstance) {
            if (!objMap.containsKey(key) ) {
            objMap.put(key, instance) ;}}
    public static ObjectgetService(String key) {
            return objMap.get(key) ;}}

// 给实例构造函数protected或private权限，可以通过相关反射方法，改变其权限，创建多个实例
public class Test {
    public static void main(String args[]) {
    private Singleton() {};
    Singleton singleton = Singleton.getInstance();try
    {
            Constructor<Singleton> constructor = Singleton.class.getDeclaredConstructor();
            constructor.setAccessible(true);
            Singleton singletonnew = constructor.newInstance();
            System.out.println(singleton == singletonnew);
            // 输出结果为 false
        }catch(
    Exception e){
    }}}
    // 解决方案：可以给构造函数加上判断，限制创建多个实例，
    private Singleton() {
            if (null != Singleton.singleton) {
            throw new RuntimeException();}}
```

### 对象 建造者模式

将一个复杂对象分布创建。如果一个超大的类的属性特别多，我们可以把属性分门别类，不同属性组成一个稍微小一点的类，再把好几个稍微小点的类窜起来。比方说一个电脑，可以分成不同的稍微小点的部分CPU、主板、显示器。CPU、主板、显示器分别有更多的组件，不再细分。

```java
@Data
public class Computer{
    private CPU cpu;//cpu 是个接口，有不同实现如InterCPU AMDCPU 等等
    private MainBoard mainBoard;//mainBoard 是个接口，有不同的实现
    private DisPlayer disPlayer;//disPlayer 是个接口，有不同的实现}

public abstract class Builder { 
    abstract void buildCPU(); 
    abstract void buildMainBoard(); 
    abstract void buildDisPlayer(); 
    abstract Computer createComputer(); } 

public class XiaoMiBuilder extends Builder{
    private Computer computer = new Computer();
    @Override
    void buildCPU() {
        computer.setCpu(new InterCPU());}
    @Override
    void buildMainBoard() {
        computer.setMainBoard(new AMainBoard());}
    @Override
    void buildDisPlayer() {
        computer.setDisPlayer(new ADisPlayer());}
    @Override
    Computer createComputer() {
        return computer;}}
```

SpringBoot实现了0配置，几乎所有的配置都写到了java代码中，大量的配置不得不让配置类采用建造者模式，这样层次比较清晰。

## 结构型

### 类 适配器模式

FutureTask 本身实现了RunnableFuture,构造器又注入了Callable,这是一个适配器模式

1. 构造方法一：传入参数为Callable接口

    ```java
    public class FutureTask<V> implements RunnableFuture<V>;

    public FutureTask(Callable<V> callable) {
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;
        this.state = NEW; }      // ensure visibility of callable}
    ```

2. 构造方法二：传入的参数为Runnable接口

    ```java
    // 这是FutureTask的构造方法
    public FutureTask(Runnable runnable, V result) {
        // 调用Executors类中的callable方法进行转化
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;}       // ensure visibility of callable}
    ```

- Executors类中的callable方法

    ```java
    public static <T> Callable<T> callable(Runnable task, T result) {
        if (task == null)
            throw new NullPointerException();
        // 返回类型是Callable
        // 这里就开始使用适配器模式了
        return new RunnableAdapter<T>(task, result);}
    ```

- 在Executors中内部类：即我们的适配器类

    ```java
    // 实现了Callable接口
    static final class RunnableAdapter<T> implements Callable<T> {
        final Runnable task;
        final T result;
        // 传入Runnable接口（实现类）和返回值
        RunnableAdapter(Runnable task, T result) {
            this.task = task;
            this.result = result;}

        // 实现call（）方法
        public T call() {
            // 在call方法中调用Runnable实现类中的run（）方法
            // 变相实现了将Runnable转化为Callable的过程
            task.run();
            // 返回值（Callable接口的call方法有返回值）
            return result;}}
    ```

#### 适配器模式演示2

适配器，顾名思义，是让两个不兼容的东西可以一起工作。例如插座的电源是220V，手机直接给他220V 50HZ的交流电我相信一般都会直接炸了（除了诺基亚...）手机充电器就进行了适配，将电压变小，交流电变成直流电。除了这种需要改变属性的操作（比较好说，不举例子了），适配器还用于在接口继承方面。假设一个顶级接口有一大堆方法需要实现类实现，我新写了个类只是想选择的实现一两个接口，那其他的方法我是不是都需要实现一下，即使是空实现（单纯实现，不进行任何逻辑操作），这是我们就需要一个适配器类，空实现那些方法，我的新类只需要继承这个适配器类就好了，要是想实现某个方法，只需要重写掉配置类中对应的方法就好。这种模式基本都会用到，毕竟谁的代码还没个顶级接口啊。

```java
public interface ATopIntf {
    public void one();
    public void two();
    public void three();}

public class Adapter implements ATopIntf {
    @Override
    public void one() { }
    @Override
    public void two() { }
    @Override
    public void three() { }}

public class You extends Adapter {
    @Override
    public void one() {
        super.one();
        System.out.println("one");}}
```

### 对象 装饰模式(Decorator)(包装器模式(Wrapper))

装饰模式
一个装饰类，在原来类的基础上增加一点功能。是不是和代理模式很像，我甚至可以将整个代码搬过来照样可以说的通的。这两个模式意思上有点差别，代理模式是原对象做不了那件事，必须让代理对象去做，主导侧重于代理对象，比如说买车。装饰模式是说，就是让原对象直接去做这件事，只是功能上增强一点，主导在于原对象。比如说炒菜的时候撒点盐。

### 对象 代理模式

Spring的AOP用的是动态代理，何为动态不看了，用过Spring的小伙伴都知道吧。单纯看一下最基础代理模式是什么样的。代理就是，一个对象辅助另一个对象去做某件事，同时还可以增加一点辅助功能。例如，你买车，的确是你花钱把车买到了，但是你不可能直接去和厂家谈吧，你应该通过4S店购买，同时4S店帮助你入保险扣税等操作，最终你才得到了你想要的车。

```java
public interface Buy {
    public void buyCar();}
    
public class People implements Buy {
    @Override
    public void buyCar() {
        System.out.println("you get a car");}}

public class ProxyPeople implements Buy{
    private People people;
    public ProxyPeople(People people){
        this.people=people;}

    @Override
    public void buyCar() {
        System.out.println("4s店帮你纳税、上保险...");
        people.buyCar();}

    public static void main(String[] args) {
        Buy buy = new ProxyPeople(new People());
        buy.buyCar();}}

//输出：
4s店帮你纳税、上保险...
you get a car
```

### 对象 桥接模式

就是用于抽象化和实现化的解耦。又是解耦，貌似设计模式就是教我们如何优雅的解耦。提高了代码的拓展性，并且可以实现代码的动态切换。
最开始的Ball、Soccer、BasketBall接着用，增加新的类

```java
public  class BallCut {
    private Ball ball;
    public Ball getBall() {
        return ball;}

    public void setBall(Ball ball) {
        this.ball = ball;}

    public void create(){
         System.out.println(ball.create());}

    public static void main(String[] args) {
        BallCut ballCut = new BallCut();
        ballCut.setBall(new Soccer());
        ballCut.create(); //give you a soccer
        ballCut.setBall(new BasketBall());
        ballCut.create(); //give you a basketBall}}
```

## 行为型

### 类

### 对象 观察者模式

一个对象(subject)被其他多个对象(observer)所依赖。则当一个对象变化时，发出通知，其它依赖该对象的对象都会收到通知，并且随着变化。

比如 声音报警器和闪光灯报警器分别订阅热水器温度，热水器温度过高时，发出通知，两个报警器分别发声、闪光以实现报警。
又比如很多人订阅微信公众号，该公众号有更新文章时，自动通知每个订阅的用户。

```java
public interface Observer {  
    public void update();}  

public class Observer1 implements Observer {  

    @Override  
    public void update() {  
        System.out.println("observer1 has received!");}}  

public class Observer2 implements Observer {  

    @Override  
    public void update() {  
        System.out.println("observer2 has received!");}}

public interface Subject {  

    /*增加观察者*/  
    public void add(Observer observer);  

    /*删除观察者*/  
    public void del(Observer observer);  

    /*通知所有的观察者*/  
    public void notifyObservers();  

    /*自身的操作*/  
    public void operation();}

public abstract class AbstractSubject implements Subject {  

    private Vector<Observer> vector = new Vector<Observer>();  
    @Override  
    public void add(Observer observer) {  
        vector.add(observer);}

    @Override  
    public void del(Observer observer) {  
        vector.remove(observer);}

    @Override  
    public void notifyObservers() {  
        Enumeration<Observer> enumo = vector.elements();  
        while(enumo.hasMoreElements()){  
            enumo.nextElement().update();}}

public class MySubject extends AbstractSubject {  

    @Override  
    public void operation() {  
        System.out.println("update self!");  
        notifyObservers();}}

public class ObserverTest {  

    public static void main(String[] args) {  
        Subject sub = new MySubject();  
        sub.add(new Observer1());  //订阅这个对象
        sub.add(new Observer2());  

        sub.operation();  //发出改变的一个通知}} 

```

### 对象 策略模式 & 与工厂模式的区别

- 定义与使用场合：一个系统需要动态地在几种类似的算法中选择一种。
- 与工厂模式异同：实例化一个对象的位置不同。对工厂模式而言，实例化对象是放在了工厂类里面。而策略模式实例化对象的操作在调用的地方。本质都是继承与多态。
- 例子： 现有 加/减/乘 几种算法，输入参数返回值都一样（可以理解成类似的算法）。现在需要在调用时动态配置算法策略，实现对不同算法的调用。

```java
public interface Strategy {
   public int doOperation(int num1, int num2);}

public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 + num2;}}

public class OperationSubstract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 - num2;}}

public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 * num2;}}

public class Context {
   private Strategy strategy;

   public Context(Strategy strategy){
      this.strategy = strategy;}

   public int executeStrategy(int num1, int num2){
      return strategy.doOperation(num1, num2);}}

public class StrategyPatternDemo {
   public static void main(String[] args) {
       //实例化对象的位置在调用处
      Context context = new Context(new OperationAdd());        
      System.out.println("10 + 5 = " + context.executeStrategy(10, 5));

      context = new Context(new OperationSubstract());        
      System.out.println("10 - 5 = " + context.executeStrategy(10, 5));

      context = new Context(new OperationMultiply());        
      System.out.println("10 * 5 = " + context.executeStrategy(10, 5));}}
```

另一种实现 Map+函数式接口

用上了Java8的新特性lambda表达式

- 判断条件放在key中
- 对应的业务逻辑放在value中

这样子写的好处是非常直观，能直接看到「判断条件对应的业务逻辑」

需求：根据优惠券(资源)类型「resourceType」和编码「resourceId」查询派发方式「grantType」

```java
@Service
public class QueryGrantTypeService {
 
    @Autowired
    private GrantTypeSerive grantTypeSerive;
    private Map<String, Function<String,String>> grantTypeMap=new HashMap<>();

    /**
     *  初始化业务分派逻辑,代替了if-else部分
     *  key: 优惠券类型
     *  value: lambda表达式,最终会获得该优惠券的发放方式
     */
    @PostConstruct
    public void dispatcherInit(){
        grantTypeMap.put("红包",resourceId->grantTypeSerive.redPaper(resourceId));
        grantTypeMap.put("购物券",resourceId->grantTypeSerive.shopping(resourceId));
        grantTypeMap.put("qq会员",resourceId->grantTypeSerive.QQVip(resourceId));}
 
    public String getResult(String resourceType){
        //Controller根据 优惠券类型resourceType、编码resourceId 去查询 发放方式grantType
        Function<String,String> result=getGrantTypeMap.get(resourceType);
        if(result!=null){
         //传入resourceId 执行这段表达式获得String型的grantType
            return result.apply(resourceId);}

        return "查询不到该优惠券的发放方式";}}
```

如果单个 if 语句块的业务逻辑有很多行的话，我们可以把这些 业务操作抽出来，写成一个单独的Service，即：

```java
//具体的逻辑操作
// 入参String resourceId是用来查数据库的，这里简化了，传参之后不做处理。
@Service
public class GrantTypeSerive {

    public String redPaper(String resourceId){
        //红包的发放方式
        return "每周末9点发放";}

    public String shopping(String resourceId){
        //购物券的发放方式
        return "每周三9点发放";}

    public String QQVip(String resourceId){
        //qq会员的发放方式
        return "每周一0点开始秒杀";}}

@RestController
public class GrantTypeController {

    @Autowired
    private QueryGrantTypeService queryGrantTypeService;

    @PostMapping("/grantType")
    public String test(String resourceName){
        return queryGrantTypeService.getResult(resourceName);}}
```

**总结**: 策略模式通过接口、实现类、逻辑分派来完成，把 「if语句块」的逻辑抽出来写成「一个类」，更好维护。  
Map+函数式接口通过Map.get(key)来代替 if-else的业务分派，能够避免策略模式带来的类增多、难以俯视整个业务逻辑的问题。

#### 策略模式演示2

策略模式
定义一组算法, 将每个算法都封装起来, 并且使它们之间可以互换。可以说是一组算法的封装，根据客户端给出的不同要求，进行不同的运算。比如下面这个简易计算器。

```java
public interface Strategy {
     public void operate();}

//妙计一：初到吴国
public class BackDoor implements Strategy {
     @Override
     public void operate() {
          System.out.println("找乔国老帮忙，让吴国太给孙权施加压力，使孙权不能杀刘备");}}

// 三个实现类（ConcreteStrategy）

//求吴国太开绿灯放行
public class GivenGreenLight implements Strategy {
     @Override
     public void operate() {
          System.out.println("求吴国太开个绿灯，放行");}}
 
//孙夫人断后，挡住追兵
public class BlackEnemy implements Strategy {
     @Override
     public void operate() {
          System.out.println("孙夫人断后，挡住追兵");}}
```

环境类（Context)

```java
public class Context {
     private Strategy strategy;
     //构造函数，要你使用哪个妙计
     public Context(Strategy strategy){
          this.strategy = strategy;}
     
     public void setStrategy(Strategy strategy){
          this.strategy = strategy;}
     
     public void operate(){
          this.strategy.operate();}}
```

下面就是使用的情况了

```java
public class Zhaoyun {
 
public static void main(String[] args) {
     Context context;
 
     System.out.println("----------刚到吴国使用第一个锦囊---------------");
     context = new Context(new BackDoor());
     context.operate();
     System.out.println("\n");
 
     System.out.println("----------刘备乐不思蜀使用第二个锦囊---------------");
     context.setStrategy(new GivenGreenLight());
     context.operate();
     System.out.println("\n");
 
     System.out.println("----------孙权的追兵来了，使用第三个锦囊---------------");
     context.setStrategy(new BlackEnemy());
     context.operate();
     System.out.println("\n");}}
```
