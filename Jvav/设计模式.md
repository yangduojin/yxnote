# 设计模式

![设计模式总分类](/Jvav/img/designPatternsCategory.png)

- [设计模式](#设计模式)
  - [创建型](#创建型)
    - [创建型-类](#创建型-类)
      - [工厂模式](#工厂模式)
    - [创建型-对象](#创建型-对象)
      - [抽象工厂模式](#抽象工厂模式)
      - [单例模式](#单例模式)
      - [建造者模式](#建造者模式)
  - [结构型](#结构型)
    - [结构型-类](#结构型-类)
      - [适配器模式](#适配器模式)
      - [适配器模式演示2](#适配器模式演示2)
    - [结构型-对象](#结构型-对象)
      - [装饰模式(Decorator)(包装器模式(Wrapper))](#装饰模式decorator包装器模式wrapper)
      - [代理模式](#代理模式)
      - [桥接模式](#桥接模式)
  - [行为型](#行为型)
    - [行为型-类](#行为型-类)
    - [行为型-对象](#行为型-对象)
      - [观察者模式](#观察者模式)
      - [策略模式 & 与工厂模式的区别](#策略模式--与工厂模式的区别)
      - [策略模式演示2](#策略模式演示2)

## 创建型

### 创建型-类

#### 工厂模式

```java
public interface Sender {  
    public void Send();}  

public class MailSender implements Sender {  
    @Override  
    public void Send() {  
        System.out.println("this is mailsender!");}}  

public class SmsSender implements Sender {  

    @Override  
    public void Send() {  
        System.out.println("this is sms sender!");  }}  

public class SendFactory {  

    public static Sender produceMail(){  
        return new MailSender();}  

    public static Sender produceSms(){  
        return new SmsSender();}}  

public class FactoryTest {  

    public static void main(String[] args) {      
        Sender sender = SendFactory.produceMail();  
        sender.Send();}}  
```

### 创建型-对象

#### 抽象工厂模式

```java
public interface Provider {  
    public Sender produce();}  

public class SendMailFactory implements Provider {  

    @Override  
    public Sender produce(){  
        return new MailSender();}}  

public class SendSmsFactory implements Provider{  

    @Override  
    public Sender produce() {  
        return new SmsSender();}}  

public class Test {  

    public static void main(String[] args) {  
        Provider provider = new SendMailFactory();  
        Sender sender = provider.produce();  
        sender.Send();  }}  
// 总结：如果要新增发送微信，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！
// 所有工厂模式中，抽象工厂模式最先进。
```

#### 单例模式

```java
// 懒汉
class Bank {
    private Bank() {}
    private volatile static Bank instance = null;
    public static Bank getInstance() {
        // 方式一：效率稍差
        // synchronized (Bank.class) {
        // if(instance == null){
        // instance = new Bank();}
        // return instance;}

        // 方式二：效率更高,双重检索
        if (instance == null) {
            synchronized (Bank.class) {
                if (instance == null) {
                    instance = new Bank();}}}
    return instance;}}

// 饿汉
public class SingleTon1(){
    private SingleTon1(){}
    private static SingleTon1 singleton = new SingleTon1();
public static getInstance(){return singleton ;}}

// 静态内部类,推荐此方式;JVM类加载机制来保证初始化实例对象时只有一个线程
public class Singleton {
    private Singleton() {}
    public static Singleton getInstance() {return SingletonHolder.sInstance;}
    private static class SingletonHolder {
        private static final Singleton sInstance = new Singleton();}}

// 使用容器实现单例模式
public class SingletonManager {
    private static Map<String, Object> objMap = new HashMap<String, Object>();
    private Singleton() { }public static void registerService(String key, Objectinstance) {
            if (!objMap.containsKey(key) ) {
            objMap.put(key, instance) ;}}
    public static ObjectgetService(String key) {
            return objMap.get(key) ;}}

// 给实例构造函数protected或private权限，可以通过相关反射方法，改变其权限，创建多个实例
public class Test {
    public static void main(String args[]) {
    private Singleton() {};
    Singleton singleton = Singleton.getInstance();try
    {
            Constructor<Singleton> constructor = Singleton.class.getDeclaredConstructor();
            constructor.setAccessible(true);
            Singleton singletonnew = constructor.newInstance();
            System.out.println(singleton == singletonnew);
            // 输出结果为 false
        }catch(
    Exception e){
    }}}
    // 解决方案：可以给构造函数加上判断，限制创建多个实例，
    private Singleton() {
            if (null != Singleton.singleton) {
            throw new RuntimeException();}}
```

#### 建造者模式

将一个复杂对象分布创建。如果一个超大的类的属性特别多，我们可以把属性分门别类，不同属性组成一个稍微小一点的类，再把好几个稍微小点的类窜起来。比方说一个电脑，可以分成不同的稍微小点的部分CPU、主板、显示器。CPU、主板、显示器分别有更多的组件，不再细分。

```java
@Data
public class Computer{
    private CPU cpu;//cpu 是个接口，有不同实现如InterCPU AMDCPU 等等
    private MainBoard mainBoard;//mainBoard 是个接口，有不同的实现
    private DisPlayer disPlayer;//disPlayer 是个接口，有不同的实现}

public abstract class Builder { 
    abstract void buildCPU(); 
    abstract void buildMainBoard(); 
    abstract void buildDisPlayer(); 
    abstract Computer createComputer(); } 

public class XiaoMiBuilder extends Builder{
    private Computer computer = new Computer();
    @Override
    void buildCPU() {
        computer.setCpu(new InterCPU());}
    @Override
    void buildMainBoard() {
        computer.setMainBoard(new AMainBoard());}
    @Override
    void buildDisPlayer() {
        computer.setDisPlayer(new ADisPlayer());}
    @Override
    Computer createComputer() {
        return computer;}}
```

SpringBoot实现了0配置，几乎所有的配置都写到了java代码中，大量的配置不得不让配置类采用建造者模式，这样层次比较清晰。

## 结构型

### 结构型-类

#### 适配器模式

FutureTask 本身实现了RunnableFuture,构造器又注入了Callable,这是一个适配器模式

1. 构造方法一：传入参数为Callable接口

    ```java
    public class FutureTask<V> implements RunnableFuture<V>;

    public FutureTask(Callable<V> callable) {
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;
        this.state = NEW; }      // ensure visibility of callable}
    ```

2. 构造方法二：传入的参数为Runnable接口

    ```java
    // 这是FutureTask的构造方法
    public FutureTask(Runnable runnable, V result) {
        // 调用Executors类中的callable方法进行转化
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;}       // ensure visibility of callable}
    ```

- Executors类中的callable方法

    ```java
    public static <T> Callable<T> callable(Runnable task, T result) {
        if (task == null)
            throw new NullPointerException();
        // 返回类型是Callable
        // 这里就开始使用适配器模式了
        return new RunnableAdapter<T>(task, result);}
    ```

- 在Executors中内部类：即我们的适配器类

    ```java
    // 实现了Callable接口
    static final class RunnableAdapter<T> implements Callable<T> {
        final Runnable task;
        final T result;
        // 传入Runnable接口（实现类）和返回值
        RunnableAdapter(Runnable task, T result) {
            this.task = task;
            this.result = result;}

        // 实现call（）方法
        public T call() {
            // 在call方法中调用Runnable实现类中的run（）方法
            // 变相实现了将Runnable转化为Callable的过程
            task.run();
            // 返回值（Callable接口的call方法有返回值）
            return result;}}
    ```

#### 适配器模式演示2

适配器，顾名思义，是让两个不兼容的东西可以一起工作。例如插座的电源是220V，手机直接给他220V 50HZ的交流电我相信一般都会直接炸了（除了诺基亚...）手机充电器就进行了适配，将电压变小，交流电变成直流电。除了这种需要改变属性的操作（比较好说，不举例子了），适配器还用于在接口继承方面。假设一个顶级接口有一大堆方法需要实现类实现，我新写了个类只是想选择的实现一两个接口，那其他的方法我是不是都需要实现一下，即使是空实现（单纯实现，不进行任何逻辑操作），这是我们就需要一个适配器类，空实现那些方法，我的新类只需要继承这个适配器类就好了，要是想实现某个方法，只需要重写掉配置类中对应的方法就好。这种模式基本都会用到，毕竟谁的代码还没个顶级接口啊。

```java
public interface ATopIntf {
    public void one();
    public void two();
    public void three();}

public class Adapter implements ATopIntf {
    @Override
    public void one() { }
    @Override
    public void two() { }
    @Override
    public void three() { }}

public class You extends Adapter {
    @Override
    public void one() {
        super.one();
        System.out.println("one");}}
```

### 结构型-对象

#### 装饰模式(Decorator)(包装器模式(Wrapper))

装饰模式
一个装饰类，在原来类的基础上增加一点功能。是不是和代理模式很像，我甚至可以将整个代码搬过来照样可以说的通的。这两个模式意思上有点差别，代理模式是原对象做不了那件事，必须让代理对象去做，主导侧重于代理对象，比如说买车。装饰模式是说，就是让原对象直接去做这件事，只是功能上增强一点，主导在于原对象。比如说炒菜的时候撒点盐。

#### 代理模式

Spring的AOP用的是动态代理，何为动态不看了，用过Spring的小伙伴都知道吧。单纯看一下最基础代理模式是什么样的。代理就是，一个对象辅助另一个对象去做某件事，同时还可以增加一点辅助功能。例如，你买车，的确是你花钱把车买到了，但是你不可能直接去和厂家谈吧，你应该通过4S店购买，同时4S店帮助你入保险扣税等操作，最终你才得到了你想要的车。

```java
public interface Buy {
    public void buyCar();}
    
public class People implements Buy {
    @Override
    public void buyCar() {
        System.out.println("you get a car");}}

public class ProxyPeople implements Buy{
    private People people;
    public ProxyPeople(People people){
        this.people=people;}

    @Override
    public void buyCar() {
        System.out.println("4s店帮你纳税、上保险...");
        people.buyCar();}

    public static void main(String[] args) {
        Buy buy = new ProxyPeople(new People());
        buy.buyCar();}}

//输出：
4s店帮你纳税、上保险...
you get a car
```

#### 桥接模式

就是用于抽象化和实现化的解耦。又是解耦，貌似设计模式就是教我们如何优雅的解耦。提高了代码的拓展性，并且可以实现代码的动态切换。
最开始的Ball、Soccer、BasketBall接着用，增加新的类

```java
public  class BallCut {
    private Ball ball;
    public Ball getBall() {
        return ball;}

    public void setBall(Ball ball) {
        this.ball = ball;}

    public void create(){
         System.out.println(ball.create());}

    public static void main(String[] args) {
        BallCut ballCut = new BallCut();
        ballCut.setBall(new Soccer());
        ballCut.create(); //give you a soccer
        ballCut.setBall(new BasketBall());
        ballCut.create(); //give you a basketBall}}
```

## 行为型

### 行为型-类

### 行为型-对象

#### 观察者模式

一个对象(subject)被其他多个对象(observer)所依赖。则当一个对象变化时，发出通知，其它依赖该对象的对象都会收到通知，并且随着变化。

比如 声音报警器和闪光灯报警器分别订阅热水器温度，热水器温度过高时，发出通知，两个报警器分别发声、闪光以实现报警。
又比如很多人订阅微信公众号，该公众号有更新文章时，自动通知每个订阅的用户。

```java
public interface Observer {  
    public void update();}  

public class Observer1 implements Observer {  

    @Override  
    public void update() {  
        System.out.println("observer1 has received!");}}  

public class Observer2 implements Observer {  

    @Override  
    public void update() {  
        System.out.println("observer2 has received!");}}

public interface Subject {  

    /*增加观察者*/  
    public void add(Observer observer);  

    /*删除观察者*/  
    public void del(Observer observer);  

    /*通知所有的观察者*/  
    public void notifyObservers();  

    /*自身的操作*/  
    public void operation();}

public abstract class AbstractSubject implements Subject {  

    private Vector<Observer> vector = new Vector<Observer>();  
    @Override  
    public void add(Observer observer) {  
        vector.add(observer);}

    @Override  
    public void del(Observer observer) {  
        vector.remove(observer);}

    @Override  
    public void notifyObservers() {  
        Enumeration<Observer> enumo = vector.elements();  
        while(enumo.hasMoreElements()){  
            enumo.nextElement().update();}}

public class MySubject extends AbstractSubject {  

    @Override  
    public void operation() {  
        System.out.println("update self!");  
        notifyObservers();}}

public class ObserverTest {  

    public static void main(String[] args) {  
        Subject sub = new MySubject();  
        sub.add(new Observer1());  //订阅这个对象
        sub.add(new Observer2());  

        sub.operation();  //发出改变的一个通知}} 

```

#### 策略模式 & 与工厂模式的区别

- 定义与使用场合：一个系统需要动态地在几种类似的算法中选择一种。
- 与工厂模式异同：实例化一个对象的位置不同。对工厂模式而言，实例化对象是放在了工厂类里面。而策略模式实例化对象的操作在调用的地方。本质都是继承与多态。
- 例子： 现有 加/减/乘 几种算法，输入参数返回值都一样（可以理解成类似的算法）。现在需要在调用时动态配置算法策略，实现对不同算法的调用。

```java
public interface Strategy {
   public int doOperation(int num1, int num2);}

public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 + num2;}}

public class OperationSubstract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 - num2;}}

public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 * num2;}}

public class Context {
   private Strategy strategy;

   public Context(Strategy strategy){
      this.strategy = strategy;}

   public int executeStrategy(int num1, int num2){
      return strategy.doOperation(num1, num2);}}

public class StrategyPatternDemo {
   public static void main(String[] args) {
       //实例化对象的位置在调用处
      Context context = new Context(new OperationAdd());        
      System.out.println("10 + 5 = " + context.executeStrategy(10, 5));

      context = new Context(new OperationSubstract());        
      System.out.println("10 - 5 = " + context.executeStrategy(10, 5));

      context = new Context(new OperationMultiply());        
      System.out.println("10 * 5 = " + context.executeStrategy(10, 5));}}
```

另一种实现 Map+函数式接口

用上了Java8的新特性lambda表达式

- 判断条件放在key中
- 对应的业务逻辑放在value中

这样子写的好处是非常直观，能直接看到「判断条件对应的业务逻辑」

需求：根据优惠券(资源)类型「resourceType」和编码「resourceId」查询派发方式「grantType」

```java
@Service
public class QueryGrantTypeService {
 
    @Autowired
    private GrantTypeSerive grantTypeSerive;
    private Map<String, Function<String,String>> grantTypeMap=new HashMap<>();

    /**
     *  初始化业务分派逻辑,代替了if-else部分
     *  key: 优惠券类型
     *  value: lambda表达式,最终会获得该优惠券的发放方式
     */
    @PostConstruct
    public void dispatcherInit(){
        grantTypeMap.put("红包",resourceId->grantTypeSerive.redPaper(resourceId));
        grantTypeMap.put("购物券",resourceId->grantTypeSerive.shopping(resourceId));
        grantTypeMap.put("qq会员",resourceId->grantTypeSerive.QQVip(resourceId));}
 
    public String getResult(String resourceType){
        //Controller根据 优惠券类型resourceType、编码resourceId 去查询 发放方式grantType
        Function<String,String> result=getGrantTypeMap.get(resourceType);
        if(result!=null){
         //传入resourceId 执行这段表达式获得String型的grantType
            return result.apply(resourceId);}

        return "查询不到该优惠券的发放方式";}}
```

如果单个 if 语句块的业务逻辑有很多行的话，我们可以把这些 业务操作抽出来，写成一个单独的Service，即：

```java
//具体的逻辑操作
// 入参String resourceId是用来查数据库的，这里简化了，传参之后不做处理。
@Service
public class GrantTypeSerive {

    public String redPaper(String resourceId){
        //红包的发放方式
        return "每周末9点发放";}

    public String shopping(String resourceId){
        //购物券的发放方式
        return "每周三9点发放";}

    public String QQVip(String resourceId){
        //qq会员的发放方式
        return "每周一0点开始秒杀";}}

@RestController
public class GrantTypeController {

    @Autowired
    private QueryGrantTypeService queryGrantTypeService;

    @PostMapping("/grantType")
    public String test(String resourceName){
        return queryGrantTypeService.getResult(resourceName);}}
```

**总结**: 策略模式通过接口、实现类、逻辑分派来完成，把 「if语句块」的逻辑抽出来写成「一个类」，更好维护。  
Map+函数式接口通过Map.get(key)来代替 if-else的业务分派，能够避免策略模式带来的类增多、难以俯视整个业务逻辑的问题。

#### 策略模式演示2

策略模式
定义一组算法, 将每个算法都封装起来, 并且使它们之间可以互换。可以说是一组算法的封装，根据客户端给出的不同要求，进行不同的运算。比如下面这个简易计算器。

```java
public interface Strategy {
     public void operate();}

//妙计一：初到吴国
public class BackDoor implements Strategy {
     @Override
     public void operate() {
          System.out.println("找乔国老帮忙，让吴国太给孙权施加压力，使孙权不能杀刘备");}}

// 三个实现类（ConcreteStrategy）

//求吴国太开绿灯放行
public class GivenGreenLight implements Strategy {
     @Override
     public void operate() {
          System.out.println("求吴国太开个绿灯，放行");}}
 
//孙夫人断后，挡住追兵
public class BlackEnemy implements Strategy {
     @Override
     public void operate() {
          System.out.println("孙夫人断后，挡住追兵");}}
```

环境类（Context)

```java
public class Context {
     private Strategy strategy;
     //构造函数，要你使用哪个妙计
     public Context(Strategy strategy){
          this.strategy = strategy;}
     
     public void setStrategy(Strategy strategy){
          this.strategy = strategy;}
     
     public void operate(){
          this.strategy.operate();}}
```

下面就是使用的情况了

```java
public class Zhaoyun {
 
public static void main(String[] args) {
     Context context;
 
     System.out.println("----------刚到吴国使用第一个锦囊---------------");
     context = new Context(new BackDoor());
     context.operate();
     System.out.println("\n");
 
     System.out.println("----------刘备乐不思蜀使用第二个锦囊---------------");
     context.setStrategy(new GivenGreenLight());
     context.operate();
     System.out.println("\n");
 
     System.out.println("----------孙权的追兵来了，使用第三个锦囊---------------");
     context.setStrategy(new BlackEnemy());
     context.operate();
     System.out.println("\n");}}
```
