# 分布式锁的实现方式 主流有三种

## 基于数据库

基于数据库主键：插入一条数据，指定主键。如果有两条插入会主键冲突，并发执行失败

基于数据库排他锁：提交一个update事务，如果这个事务不提交，其他也对锁定范围内执行update就会阻塞，解决并发问题

性能低，还有可能出现锁表

## 基于缓存比如redis的setNX

### redis并发竞争key问题

如果key操作不要求顺序

- 做一个分布式锁，抢到锁就做set操作
  
如果key操作要求顺序

- 数据写入数据库时保存一个时间戳，如果后面的系统先抢到锁，执行了更改，前面操作的系统发现时间戳在自己之后，就不做set操作

1. 它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。
2. 另外来说的话，redis的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮
3. 即便使用redlock算法来实现，在某些复杂场景下，也无法保证其实现100%没有问题，关于redlock的讨论可以看How to do distributed locking
4. redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。

redis实现分布式锁在很多企业中非常常见，而且大部分情况下都不会遇到所谓的“极端复杂场景”。且redis的性能很高，可以支撑高并发的获取、释放锁操作。

```java
public void testRedis() {
    String uuid = UUID.randomUUID().toString();
// 下面的名字加锁和设置过期时间是原子的 本质是set nx ex 一起使用
    Boolean aBoolean = redisTemplate.opsForValue().setIfAbsent("lock", "uuid",3, TimeUnit.SECONDS);
    if(aBoolean){
        String num = (String) redisTemplate.opsForValue().get("num");
        if(StringUtils.isEmpty(num)){
            num = "1";
            redisTemplate.opsForValue().set("num",num);
            redisTemplate.delete("lock");
            return;
        }
        int newNum = Integer.parseInt(num);
        redisTemplate.opsForValue().set("num",String.valueOf(++newNum));
        
//            String redisUuid = (String) redisTemplate.opsForValue().get(num);
//            if(uuid.equals(redisUuid)){
//            redisTemplate.delete("lock");
//            }
        // 这一段是对上面的三行代码的强化，增强原子性，判断和删除在同一个时间片里执行
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        redisScript.setScriptText(script);
        redisScript.setResultType(Long.class);// 执行成功后返回的类型值
        redisTemplate.execute(redisScript, Arrays.asList("lock"),uuid);
    }else {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        testRedis();}}
```

### Redission

使用需要配置@Bean RedissonClient

所有指令都是通过lua脚本执行，redis支持lua脚本原子性执行

redission 不指定过期时间,看门狗自动续期,如果程序执行完成,锁自动释放.程序崩溃也会解锁;

如指定时间则到时释放锁;

如果程序释放锁操作时因为异常没有被执行，那么锁无法被释放，所以释放锁操作一定要放到 finally {} 中;

// 可以启动两个服务,用不同的端口访问 中间停掉可以发现 redisson 会自动设置锁过期时间,而且业务常长会自动续时间

// 异常断电不用担心业务时间长,锁时间到会自动过期;加锁的业务只要完成就不会自动续期,不用担心死锁,续期次数限制?

```java
public void testRedission22() {//redission
    RLock lock = redissonClient.getLock("lock");
    lock.lock(10, TimeUnit.SECONDS);// 看门狗 超时自动释放
    String value = (String) redisTemplate.opsForValue().get("num");
    if (StringUtils.isEmpty(value)) {
        redisTemplate.opsForValue().set("num", "1");
    } else {
        int num = Integer.parseInt(value);
        redisTemplate.opsForValue().set("num", String.valueOf(++num));
    }
    lock.unlock();
}
public void testRedission33() {//redission
    RLock lock = redissonClient.getLock("lock");
    try {
        /**
            * 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败
            * 锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）
            */
        boolean acquireLock = lock.tryLock(100, 10, TimeUnit.SECONDS);
        if(acquireLock){
            String value = (String) redisTemplate.opsForValue().get("num");
            if (StringUtils.isEmpty(value)) {
                redisTemplate.opsForValue().set("num", "1");
            } else {
                int num = Integer.parseInt(value);
                redisTemplate.opsForValue().set("num", String.valueOf(++num));
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}
```

第二种

```java
RLock lock = redissonClient.getLock("my-lock");  // 这是redisson的分布式锁
//        lock.lock();
lock.lock(30,TimeUnit.SECONDS); 推荐用这个,业务大于30s也必须暂停该业务,该业务时间不合理
try {
    System.out.println(Thread.currentThread().getName() + "  加锁成功,执行业务");
    Thread.sleep(10*1000);
} catch (InterruptedException e) {
    e.printStackTrace();
} finally {
    System.out.println(Thread.currentThread().getName() + "  释放锁");
    lock.unlock();
}
```

## 基于zookeeper

zookeeper并发性能差一点,可靠性高,适合已经引入zookeeper的情况,且锁应用量不大.不会引入新组件带来的风险和维护成本

在使用spring进行业务开发的时候，常见的一种场景就是使用spring配置事务。默认级别是RR。在这里面如果使用的是LBCC，一进入事务就加入一个排他锁，比如insert、update、delete或者select XXX for update。然后做其他的，比如进行一个RPC调用。这时候一旦出现并发，只有一个能顺利执行，其他都会被阻塞。实际上就相当于使用了分布式锁。

zookeeper天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。

如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。

缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于zk集群的压力会比较大。性能不如redis
