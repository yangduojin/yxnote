# 分布式事务(CAP cp ap BASE)

远程调用完成,但是因为网络问题导致主程序判定调用失败失败而回滚,导致两个数据库数据不一致.

## 2pc

2阶段提交(2-phase Commit 基于DB,强一致性)通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。
1. 准备阶段 协调者询问参与者事务是否执行成功，参与者发回事务执行结果。
2. 提交阶段 如事务在每个参与者上都执行成功，事务协调者发通知让参与者提交事务；否则，协调者发通知让参与者回滚事务。
3. 注意 在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。
    - 存在的问题 同步阻塞 所有参与者都在等待其他参与者响应，无法进行其他操作
    - 单点问题 协调做在2pc中起到非常大的作用，发生故障将会造成很大影响，特别是阶段2故障，将导致所有参与者等待，无法完成其他操作
    - 数据不一致 在阶段2 如果协调者发送commit时，网络异常只有部分参与者收到commit，则只有部分参与者提交了事务，导致系统数据不一致
    - 太过保守 任意一个节点失败将导致整个事务失败，没有完善的容错机制
  
2PC 和 3PC 都不能保证数据100%一致，因此一般都需要有定时扫描补偿机制。3PC了解即可

2pc 效率低，分布式事务很难做

## 本地消息表

本地消息表与业务数据表处于同一个数据库中，就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用消息队列来保证最终一致性。

- 写业务数据到表中 -> 
- 写消息到本地消息表(与业务为同一事务) -> 
- 消息转发给MQ，MQ成功收到 -> 
- 分布式事务操作的另一方从消息队列读取一个消息，并执行消息中的操作。并将消息表中的消息改为已完成 ->
- 签收mq中的消息(如果消息表中一直未完成则重复发送mq，多次之后转人工处理)

1. 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
2. 之后将本地消息表中的消息转发到 Kafka，MQ 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。
3. 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。

优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性.

缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。

#2 写业务之后写消息入消息表，之后调用另一个操作，完成后消息改为已完成，调用失败有定时任务读取本地消息，筛选未成功的再调用对应的服务，服务成功更新消息状态，不成功就多次重试，要保证对应服务的幂等性，超过最大尝试次数就转人工

实现的是最终一致性，容忍了数据暂时不一致的情况。

## TCC(Try commit cancel)补偿机制

基于应用层,t阶段业务确认和资源预留，还可以自己控制业务粒度，核心思想：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作

1. Try 阶段主要是对业务系统做检测及资源预留
2. Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
3. Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

优点： 跟2PC比起来，实现以及流程相对简单一些，但数据的一致性比2PC也要差一些,TCC可以跨数据库、跨不同的业务系统来实现事务。

缺点： 缺点还是比较明显的，在2,3步中都有可能失败。

TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。

TCC 对业务的侵入较大和业务紧耦合,撤销和确认操作的执行可能需要重试，因此还需要保证操作的幂等。


## MQ事务消息

1. 第一阶段Prepared消息，会拿到消息的地址。 
2. 第二阶段执行本地事务，
3. 第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。

业务方法内要向消息队列提交两次请求，
一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。
优点： 实现了最终一致性，不需要依赖本地数据库事务。
缺点： 实现难度大，主流MQ不支持，RocketMQ事务消息部分代码也未开源。


### RocketMQ 

就很好的支持了消息事务，让我们来看一下如何通过消息实现事务。
1. 第一步先给 Broker 发送事务消息即半消息，半消息不是说一半消息，而是这个消息对消费者来说不可见，然后发送成功后发送方再执行本地事务。
2. 再根据本地事务的结果向 Broker 发送 Commit 或者 RollBack 命令。
3. 并且 RocketMQ 的发送方会提供一个反查事务状态接口，如果一段时间内半消息没有收到任何操作请求，那么 Broker 会通过反查接口得知发送方事务是否执行成功，然后执行 Commit 或者 RollBack 命令。
4. 如果是 Commit 那么订阅方就能收到这条消息，然后再做对应的操作，做完了之后再消费这条消息即可。
5. 如果是 RollBack 那么订阅方收不到这条消息，等于事务就没执行过。
可以看到通过 RocketMQ 还是比较容易实现的，RocketMQ 提供了事务消息的功能，我们只需要定义好事务反查接口即可。

### 最大努力通知

本地消息表也可以算最大努力，事务消息也可以算最大努力。

只是表明了一种柔性事务的思想：我已经尽力我最大的努力想达成事务的最终一致了。

适用于对时间不敏感的业务，例如短信通知。

### 分布式事务总结

可以看出 2PC 和 3PC 是一种强一致性事务，不过还是有数据不一致，阻塞等风险，而且只能用在数据库层面。

而 TCC 是一种补偿性事务思想，适用的范围更广，在业务层面实现，因此对业务的侵入性较大，每一个操作都需要实现对应的三个方法。

本地消息、事务消息和最大努力通知其实都是最终一致性事务，因此适用于一些对时间不敏感的业务。
