## 自我介绍

面试官你好,我叫杨鑫,从事Java开发,做过几个小项目,上一个项目是积分购物app,主要使用的技术栈是SpringBoot/Cloud,Alibaba的全家桶,mysql,mybatis,缓存,消息中间件都有涉及使用,希望通过今天跟您的面试,交流知识,补充我的不足和误解


## 题目汇总

### java

#### 设计模式
1. 代理: aop就是动态代理,事务也是动态代理,mybatisMapper接口也是动态代理
  >- 实际使用的地方: 为了缓存一些数据,直接写了一个注解,使用aop,把数据缓存下来
2. 策略: 实际上就是多态,在方法里面传一个父接口,再用不同的实现类去实现,最后使用的时候根据不同的实现类参数,多态的显示不同的结果
  >- 微信,支付宝等不同的支付方式,直接传子类就可以使用对应的方法
3. 装饰者模式
  >- mybatis缓存淘汰有很多方式,最少使用,最长时间,不可能写了之后让所有的类去继承,所以需要装饰者模式去按需求添加
  >- io流有各种字节流,字符流,对象输入流,用继承的话类需要写的就越来越多,所以用装饰者模式添加需要的功能


### spring

- ioc 控制反转,取决于DI.思想的体现配置xml或者全注解配置@Bean@Configuration@Component
  - 一开始,到处new不够优雅,浪费内存,而且耦合太高,解耦思想,统一依赖一个
  - spring通过xml来配置bean,简洁,不会耦合.scope:singleton/prototype/request/session
- aop 抽离出核心流程,把不重要的抽离到切面去执行,让核心逻辑简洁优雅,同时解耦合

### jvm

- JVM遇到过什么问题
  - 需要总结一个问题
  - 垃圾回收算法 GC root: A garbage collection root is an object that is accessible from outside the heap


- 项目 挑选一个最关键的说明白 说透就行了
- ES

- JUC
  - Java8对Synchronized的优化 锁膨胀:无锁01 偏向 01 轻量 00 重量 10  GC 11  锁消除 锁粗化 自适应自旋
- 模板语言 freemaker thymeleaf
- springboot 配置文件启动顺序 bootstrap  application
- java8新特新
  - 语言新特性 接口的默认方法和静态方法 / Lambda表达式和函数式接口 / 方法引用 / 重复注解 @Repeatable
  - 官方库新特性 Optional / Streams / Date/Time API(JSR 310 Clock / LocalDate / LocalTime / LocalDateTime) / Base64 / 并行数组
- jvm内存模型
  - classloader / JVM Memory (Method Area | Heap | JVM Language Stocks | Native Method Stocks | PC Register) / Execution Engine / Native Method Interface / Native Method Libraries
- 阻塞队列:
- RabbitMQ 实现线程安全的生产者 消费者模型

### linux

### MySQL

- union 和 内连接的区别:123 23 inner 23;123 234 union 1234
- 数据库调优: 
  - 一张表数据没有那么多
  - 根据实际业务,不能所有的字段查询,如报表硬性的规定可以查那些字段
  - sql语句不要用*,模型数空运最快
  - 少用子查询,多用连接查询,子查询涉及到小表驱动大表
- mysql事务
  - ACID
- sql优化
  - 只返回需要的结果:一定要为查询语句指定 WHERE 条件，过滤掉不需要的数据行,避免使用 SELECT * FROM
  - 确保查询使用了正确的索引
    - 经常出现在 WHERE 条件中的字段建立索引可以避免全表扫描；
    - 将 ORDER BY 排序的字段加入到索引中，可以避免额外的排序操作；
    - 多表连接查询的关联字段建立索引，可以提高连接查询的性能；
    - 将 GROUP BY 分组操作字段加入到索引中，可以利用索引完成分组。
    - 索引失效
      - 对索引字段进行表达式运算或者使用函数
      - 字段的数据类型不匹配
      - like 通配符出现在左侧无法使用索引
      -  WHERE 条件中的字段上创建了索引，尽量设置为 NOT NULL
    - 过执行计划（EXPLAIN）确保查询使用了正确的索引。
  - 尽量避免使用子查询
  - 不要使用 OFFSET 实现分页:SELECT * FROM large_table ORDER BY id LIMIT 10 OFFSET N;对于以上分页查询，更好的方法是记住上一次获取到的最大 id，然后在下一次查询中作为条件传入  
  - 了解 SQL 子句的逻辑执行顺序
    - WHERE 子句在 HAVING 子句之前执行，因此我们应该尽量使用 WHERE 进行数据过滤，避免无谓的操作；除非业务需要针对聚合函数的结果进行过滤。
  - 主键索引和唯一索引的区别
    - 主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。
    - 主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。
    - 唯一性索引列允许空值，而主键列不允许为空值。
    - 主键列在创建时，已经默认为空值 + 唯一索引了。
    - 主键可以被其他表引用为外键，而唯一索引不能。
    - 一个表最多只能创建一个主键，但可以创建多个唯一索引。
    - 主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。



[深入分析Synchronized原理(阿里面试题) - aspirant - 博客园](https://www.cnblogs.com/aspirant/p/11470858.html)